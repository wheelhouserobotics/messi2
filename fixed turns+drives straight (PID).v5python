{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\n# AI Classification Competition Element IDs\nclass GameElements:\n    MOBILE_GOAL = 0\n    RED_RING = 1\n    BLUE_RING = 2\nleft_motor_a = Motor(Ports.PORT20, GearSetting.RATIO_18_1, True)\nleft_motor_b = Motor(Ports.PORT11, GearSetting.RATIO_18_1, True)\nleft_drive_smart = MotorGroup(left_motor_a, left_motor_b)\nright_motor_a = Motor(Ports.PORT12, GearSetting.RATIO_18_1, False)\nright_motor_b = Motor(Ports.PORT16, GearSetting.RATIO_18_1, False)\nright_drive_smart = MotorGroup(right_motor_a, right_motor_b)\ndrivetrain = DriveTrain(left_drive_smart, right_drive_smart, 219.44, 295, 40, MM, 1)\nleftPuem = DigitalOut(brain.three_wire_port.a)\nrightPUEM = DigitalOut(brain.three_wire_port.b)\ncontroller_1 = Controller(PRIMARY)\nintake = Motor(Ports.PORT1, GearSetting.RATIO_6_1, True)\noutake = Motor(Ports.PORT8, GearSetting.RATIO_6_1, False)\ngps_21 = Gps(Ports.PORT21, 132.08, -88.90, MM, 0)\n# AI Vision Color Descriptions\n# AI Vision Code Descriptions\nai_vision_2 = AiVision(Ports.PORT2, AiVision.ALL_AIOBJS)\nright_rotation = Rotation(Ports.PORT3, False)\nleft_rotation = Rotation(Ports.PORT14, False)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\n# Make random actually random\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    random = brain.battery.voltage(MV) + brain.battery.current(CurrentUnits.AMP) * 100 + brain.timer.system_high_res()\n    urandom.seed(int(random))\n      \n# Set random seed \ninitializeRandomSeed()\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n\n\n# define variables used for controlling motors based on controller inputs\ndrivetrain_needs_to_be_stopped_controller_1 = False\n\n# define a task that will handle monitoring inputs from controller_1\ndef rc_auto_loop_function_controller_1():\n    global drivetrain_needs_to_be_stopped_controller_1, remote_control_code_enabled\n    # process the controller input every 20 milliseconds\n    # update the motors based on the input values\n    while True:\n        if remote_control_code_enabled:\n            \n            # calculate the drivetrain motor velocities from the controller joystick axies\n            # left = axis2 + axis1\n            # right = axis2 - axis1\n            drivetrain_left_side_speed = controller_1.axis2.position() + controller_1.axis1.position()\n            drivetrain_right_side_speed = controller_1.axis2.position() - controller_1.axis1.position()\n            \n            # check if the values are inside of the deadband range\n            if abs(drivetrain_left_side_speed) < 5 and abs(drivetrain_right_side_speed) < 5:\n                # check if the motors have already been stopped\n                if drivetrain_needs_to_be_stopped_controller_1:\n                    # stop the drive motors\n                    left_drive_smart.stop()\n                    right_drive_smart.stop()\n                    # tell the code that the motors have been stopped\n                    drivetrain_needs_to_be_stopped_controller_1 = False\n            else:\n                # reset the toggle so that the deadband code knows to stop the motors next\n                # time the input is in the deadband range\n                drivetrain_needs_to_be_stopped_controller_1 = True\n            \n            # only tell the left drive motor to spin if the values are not in the deadband range\n            if drivetrain_needs_to_be_stopped_controller_1:\n                left_drive_smart.set_velocity(drivetrain_left_side_speed, PERCENT)\n                left_drive_smart.spin(FORWARD)\n            # only tell the right drive motor to spin if the values are not in the deadband range\n            if drivetrain_needs_to_be_stopped_controller_1:\n                right_drive_smart.set_velocity(drivetrain_right_side_speed, PERCENT)\n                right_drive_smart.spin(FORWARD)\n        # wait before repeating the process\n        wait(20, MSEC)\n\n# define variable for remote controller enable/disable\nremote_control_code_enabled = True\n\nrc_auto_loop_thread_controller_1 = Thread(rc_auto_loop_function_controller_1)\n\n#endregion VEXcode Generated Robot Configuration\n\nmyVariable = 0\n\ndef ondriver_drivercontrol_0():\n    global myVariable\n    while True:\n        if controller_1.buttonUp.pressing():\n            intake.set_velocity(100, PERCENT)\n            intake.spin(FORWARD)\n        if controller_1.buttonDown.pressing():\n            intake.stop()\n        if controller_1.buttonX.pressing():\n            outake.set_velocity(100, PERCENT)\n            outake.spin(FORWARD)\n        if controller_1.buttonB.pressing():\n            outake.stop()\n        if controller_1.buttonL1.pressing():\n            leftPuem.set(True)\n            rightPUEM.set(True)\n        if controller_1.buttonL2.pressing():\n            leftPuem.set(False)\n            rightPUEM.set(False)\n        wait(5, MSEC)\n\ndef when_started():\n    global myVariable\n    pass\n    \n\n\n# create a function for handling the starting and stopping of all autonomous tasks\ndef vexcode_auton_function():\n    # Start the autonomous control tasks\n    # wait for the driver control period to end\n    while( competition.is_autonomous() and competition.is_enabled() ):\n        # wait 10 milliseconds before checking again\n        wait( 10, MSEC )\n    # Stop the autonomous control tasks\n\ndef vexcode_driver_function():\n    # Start the driver control tasks\n    driver_control_task_0 = Thread( ondriver_drivercontrol_0 )\n\n    # wait for the driver control period to end\n    while( competition.is_driver_control() and competition.is_enabled() ):\n        # wait 10 milliseconds before checking again\n        wait( 10, MSEC )\n    # Stop the driver control tasks\n    driver_control_task_0.stop()\n\n\n# register the competition functions\ncompetition = Competition( vexcode_driver_function, vexcode_auton_function )\n\n\n\n\n# Import required libraries\nimport math\n\n# Parameters for turning PID control\nturn_kP = 0.35   #turn_to_heading Proportional constant\nturn_kI = 0.001    # Integral constant\nturn_kD = 0.03    # Derivative constant\nturnSpeed = 30     # Turn speed\n\ndrivetrain.set_turn_velocity(turnSpeed,PERCENT)\n\n# turn_kP = 0.2      # Proportional constant\n# turn_kI = 0.001    # Integral constant\n# turn_kD = 0.0      # Derivative constant\n# turnSpeed = 30     # Turn speed\n\nturn_tolerance = 0.35  # Acceptable error in degrees\nmin_turn_speed = 5  # Minimum turn speed to overcome friction\nmax_turn_speed = 50 # Maximum turn speed\n\ndef normalize_heading(heading):\n    \"\"\"Normalize heading to be between 0-360 degrees\"\"\"\n    while heading < 0:\n        heading += 360\n    while heading >= 360:\n        heading -= 360\n    return heading\n\ndef shortest_angle_difference(target, current):\n    \"\"\"Calculate the shortest angle to turn (handles wraparound)\"\"\"\n    diff = normalize_heading(target) - normalize_heading(current)\n    \n    # Handle cases where turning the other way is shorter\n    if diff > 180:\n        diff -= 360\n    elif diff < -180:\n        diff += 360\n        \n    return diff\n\ndef turn_to_heading(target_heading, max_speed):\n    \"\"\"\n    Turn the robot to a specific heading using PID control with GPS sensor\n    \n    Args:\n        target_heading: Target heading in degrees (0-360)\n        max_speed: Maximum turning speed (0-100)\n    \"\"\"\n    print(\"Starting turn to heading: \",target_heading,\" degrees\")\n    \n    # Normalize target heading to 0-360 range\n    target_heading = normalize_heading(target_heading)\n    \n    # PID variables\n    integral = 0\n    prev_error = 0\n    \n    # Initial error calculation\n    current_heading = gps_21.heading()\n    error = shortest_angle_difference(target_heading, current_heading)\n    \n    # Continue until we're close enough to the target\n    timer = Timer()  # Used to detect if we're stuck\n    timer.reset()\n    \n    while abs(error) > turn_tolerance:\n        # Get current heading from GPS\n        current_heading = gps_21.heading()\n        \n        # Calculate error (how far we still need to turn)\n        error = shortest_angle_difference(target_heading, current_heading)\n        \n        # Calculate integral (sum of errors over time)\n        integral += error\n        \n        # Prevent integral windup\n        if abs(integral) > 1000:\n            integral = 1000 if integral > 0 else -1000\n        \n        # If we're not making progress, reset integral\n        if timer.time(SECONDS) > 2:\n            if abs(prev_error - error) < 1:\n                integral = 0\n                print(\"Progress stalled, resetting integral\")\n            timer.reset()\n        \n        # Calculate derivative (rate of change of error)\n        derivative = error - prev_error\n        \n        # Calculate motor +9 using PID\n        power = (error * turn_kP) + (integral * turn_kI) + (derivative * turn_kD)\n\n        print(\"error: \", error, \" integral: \", integral, \" derivative: \", derivative)\n\n        print(\"Power to motors: \", power)\n        # power=20\n        \n        # # Ensure minimum power to overcome friction\n        if 0 < abs(power) < min_turn_speed:\n            power = min_turn_speed * (1 if power > 0 else -1)\n        \n        # Limit power to specified maximum\n        if abs(power) > max_speed:\n            power = max_speed * (1 if power > 0 else -1)\n        \n        # Apply motor power for turning\n        # Positive error means we need to turn clockwise\n        left_drive_smart.spin(FORWARD, power, PERCENT)\n        right_drive_smart.spin(REVERSE, power, PERCENT)\n        \n        # Debug info\n        # print(\"Current: \",current_heading,\" Target: \",target_heading,\" Err: \",error,\" Power: \",power)\n        # print(\"GPS Position X: \",gps_18.x_position(INCHES),\" mm Y: \",gps_18.y_position(INCHES),\" mm\")\n        \n        # Update previous error for next iteration\n        prev_error = error\n        \n        # Short delay to prevent CPU hogging\n        wait(20, MSEC)\n    \n    # Stop the robot once target is reached\n    left_drive_smart.stop(BRAKE)\n    right_drive_smart.stop(BRAKE)\n    print(\"Target heading reached: Current= \",gps_21.heading(),\" Target= \",target_heading)\n\ndef turn_by_angle(angle_degrees, max_speed):\n    \"\"\"\n    Turn the robot by a relative angle using the GPS sensor\n    \n    Args:\n        angle_degrees: Angle to turn in degrees (positive=clockwise, negative=counter-clockwise)\n        max_speed: Maximum turning speed (0-100)\n    \"\"\"\n    # Get current heading\n    current_heading = gps_21.heading()\n    \n    # Calculate target heading\n    target_heading = normalize_heading(current_heading + angle_degrees)\n    \n    print(\"Starting relative turn of \",angle_degrees,\" degrees\")\n    print(\"Current heading: \",current_heading,\" Target heading: \",target_heading)\n    \n    # Execute the turn\n    # turn_to_heading(target_heading, max_speed)\n    turn_to_heading(angle_degrees, max_speed)\n\n# PID constants for straight driving correction\n# These values need tuning for your specific robot\n# kP = 0.1  # Proportional gain\n# kI = 0.01  # Integral gain\n# kD = 0.1   # Derivative gain\n\nkP = 0.0 # Proportional gain\nkI = -0.15 # Integral gain\nkD = 0.00  # Derivative gain\n\n# Maximum allowed integral value to prevent wind-up\nMAX_INTEGRAL = 50\n\n# Function to reset rotation sensors\ndef reset_rotations():\n    left_rotation.reset_position()\n    right_rotation.reset_position()\n    \n# Function to drive straight for a specific distance in degrees using PID\ndef drive_straight_pid(distance_deg, speed_pct):\n    # Reset rotation sensors\n    reset_rotations()\n    \n    # Target position and PID variables\n    target_position = abs(distance_deg)\n    direction = 1 if distance_deg > 0 else -1  # Determine direction\n    \n    # PID variables\n    prev_error = 0\n    integral = 0\n    \n    # Control loop variables\n    average_position = 0\n    last_time = brain.timer.time(MSEC)\n    \n    # Loop until we reach the target distance\n    while average_position < target_position:\n        # Calculate time delta for derivative calculation\n        current_time = brain.timer.time(MSEC)\n        dt = current_time - last_time\n        dt = max(dt, 1)  # Prevent division by zero\n        last_time = current_time\n        \n        # Get current position from both rotation sensors\n        left_position = abs(left_rotation.position(DEGREES))\n        right_position = abs(right_rotation.position(DEGREES))\n        \n        # Calculate average position and error (difference between sensors)\n        average_position = (left_position + right_position) / 2\n        position_error = left_position - right_position\n        \n        # Calculate PID components\n        # Proportional term\n        p_term = position_error * kP\n        \n        # Integral term with anti-windup\n        integral += position_error * dt / 1000.0\n        integral = max(min(integral, MAX_INTEGRAL), -MAX_INTEGRAL)  # Clamp to prevent windup\n        i_term = integral * kI\n        \n        # Derivative term\n        derivative = (position_error - prev_error) / (dt / 1000.0)\n        d_term = derivative * kD\n        \n        # Calculate total correction\n        correction = p_term + i_term + d_term\n        \n        # Store error for next iteration\n        prev_error = position_error\n        \n        # Apply the correction to the motors\n        left_speed = speed_pct * direction + correction\n        right_speed = speed_pct * direction - correction\n        \n        # Constrain speeds to valid range (-100 to 100)\n        left_speed = max(min(left_speed, 100), -100)\n        right_speed = max(min(right_speed, 100), -100)\n        \n        # Set motor speeds\n        left_motor_a.spin(FORWARD, left_speed, PERCENT)\n        left_motor_b.spin(FORWARD, left_speed, PERCENT)\n        right_motor_a.spin(FORWARD, right_speed, PERCENT)\n        right_motor_b.spin(FORWARD, right_speed, PERCENT)\n        \n        # Small delay to avoid hogging CPU\n        wait(20, MSEC)\n        \n        # Display debug information\n        print(\"L: \",left_position,\" R: \",right_position,\" E: \",position_error,\" P: \",(average_position/target_position*100))\n        print(\"P: \",p_term,\" I: \",i_term,\" D: \",d_term,\"\\n\")\n        \n    # Stop all motors\n    left_motor_a.stop(BRAKE)\n    left_motor_b.stop(BRAKE)\n    right_motor_a.stop(BRAKE)\n    right_motor_b.stop(BRAKE)\n    \n    # brain.screen.set_cursor(6, 1)\n    # brain.screen.print(\"Drive complete!\")\n    print(\"Drive complete!\")\n    \n    return True\n\n# Function to aim for a specific distance and handle timeouts\ndef drive_distance_with_timeout(distance_deg, speed_pct, timeout_sec):\n     # Wait for rotation sensors to initialize\n    wait(100, MSEC)\n\n    # Start timer\n    timer = Timer()\n    \n    # Execute drive function with timeout\n    success = drive_straight_pid(distance_deg, speed_pct)\n    \n    # Check if timeout occurred\n    if timer.time(SECONDS) >= timeout_sec:\n        # brain.screen.set_cursor(7, 1)\n        # brain.screen.print(\"Drive timed out!\")\n        print(\"Drive timed out!\")\n        print(\"Drive complete!\")\n        \n        # Stop all motors\n        left_motor_a.stop(BRAKE)\n        left_motor_b.stop(BRAKE)\n        right_motor_a.stop(BRAKE)\n        right_motor_b.stop(BRAKE)\n        return False\n    \n    return success\n\n\n# Main program\ndef main():\n    gps_21.calibrate()\n    print(\"Starting GPS navigation program\")\n    print(\"Current GPS heading: \",gps_21.heading())\n    print(\"Current GPS position: X= \",gps_21.x_position(INCHES), \" IN Y= \",gps_21.y_position(INCHES),\" IN\")\n    \n    # Allow GPS to calibrate if needed\n    wait(1, SECONDS)\n    \n    # Wait for user to press a button to start\n    print(\"Press A for absolute heading, B for relative turn, X for point navigation\")\n    \n    # while True:\n    #     if controller_1.buttonA.pressing():\n    #         print(\"Button A pressed, turning to absolute heading 270°\")\n    #         turn_to_heading(90, turnSpeed) # turn to (absolute degree, speed)\n    #         # break\n    #     elif controller_1.buttonB.pressing():\n    #         print(\"Button B pressed, turning 90° clockwise\")\n    #         gpsHeading = gps_21.heading()\n\n    #         turn_by_angle(180,turnSpeed)\n    #         # break\n    #     elif controller_1.buttonX.pressing():\n    #         print(\"Button X pressed, driving straight\")\n    #         wheelDiameter=2.75 # Inches\n    #         wheelCircumference = math.pi * wheelDiameter\n    #         travelDistance = 36# Inches\n    #         error =0 # inches\n\n    #         travelDistance -= error\n\n    #         numberOfDegrees = (travelDistance/wheelCircumference) * 360\n    #         speed = 70\n            \n    #         # Drive forward 1000 degrees at 50% speed with 5 second timeout\n    #         drive_distance_with_timeout(numberOfDegrees, speed, 5)\n    #         travelDistance = 48\n    #         numberOfDegrees = (travelDistance/wheelCircumference) * 360\n    #         drive_distance_with_timeout(numberOfDegrees, speed, 5)\n    #         # break\n    #     elif controller_1.buttonY.pressing():\n    #         vision()\n    #     wait(50, MSEC)\n    \n    print(\"Program complete\")\n\n# Run the main program\nprint(\"running main\")\n\ndef objectDetails(objectAtIndex, objective):\n    \n    if(ai_vison_centerX_floor < objectAtIndex.centerX and objectAtIndex.centerX <  ai_vison_centerX_ceiling):\n            \n        print(\"OBJECT is Centered\")\n        print(\"centerX: \",objectAtIndex.centerX)\n        print(\"centerY: \",objectAtIndex.centerY)\n        print(\"Score: \",objectAtIndex.score)\n        print(\"id: \",objectAtIndex.id)\n        print(\"width: \",objectAtIndex.width)\n        print(\"height: \",objectAtIndex.height)\n        # print(\"centerX: \",objectAtIndex.centerX)\n        # print(\"centerY: \",objectAtIndex.centerY)\n        print(\"originX: \",objectAtIndex.originX)\n        print(\"originY: \",objectAtIndex.originY)\n        print(\"area: \",objectAtIndex.width * objectAtIndex.height )\n        retVal=\"C\"\n    elif(objectAtIndex.centerX < ai_vison_centerX_floor ):\n        print(\"object is to the left of the center of the robot \")\n        print(\"centerX: \",objectAtIndex.centerX)\n        print(\"centerY: \",objectAtIndex.centerY)\n        print(\"Score: \",objectAtIndex.score)\n        print(\"id: \",objectAtIndex.id)\n        print(\"width: \",objectAtIndex.width)\n        print(\"height: \",objectAtIndex.height)\n        # print(\"centerX: \",objectAtIndex.centerX)\n        # print(\"centerY: \",objectAtIndex.centerY)\n        print(\"originX: \",objectAtIndex.originX)\n        print(\"originY: \",objectAtIndex.originY)\n        print(\"area: \",objectAtIndex.width * objectAtIndex.height )\n        retVal=\"L\"\n    elif (objectAtIndex.centerX > ai_vison_centerX_ceiling):\n        print(\"object is to the right of the center of the robot \")  \n        print(\"centerX: \",objectAtIndex.centerX)\n        print(\"centerY: \",objectAtIndex.centerY)   \n        print(\"Score: \",objectAtIndex.score)\n        print(\"id: \",objectAtIndex.id)\n        print(\"width: \",objectAtIndex.width)\n        print(\"height: \",objectAtIndex.height)\n        # print(\"centerX: \",objectAtIndex.centerX)\n        # print(\"centerY: \",objectAtIndex.centerY)\n        print(\"originX: \",objectAtIndex.originX)\n        print(\"originY: \",objectAtIndex.originY)\n        print(\"area: \",objectAtIndex.width * objectAtIndex.height )\n        retVal=\"R\"\n\n    return(retVal)\n\ndef turnToObjective():\n    for dictKey,dictValue in objectiveIndexAndWidthList[0].items():\n        index = dictKey\n        turnLR = dictValue[1]   \n\n    print(\"Turn to: \", turnLR, \" index: \", index)\n\n    # Keep turning  until the object is in the\n    # center of the view.\n    \n    drivetrain.set_turn_velocity(5,PERCENT)\n\n    if(turnLR == \"R\"):\n        drivetrain.turn(RIGHT)\n        print (\"Turning right\")\n    elif(turnLR == \"L\"):\n        print (\"Turning left\")\n        drivetrain.turn(LEFT)\n    \n    while True:\n        lookingForObject = ai_vision_2.take_snapshot(AiVision.ALL_AIOBJS)\n        # print (\"Center X: \", lookingForObject[index].centerX)\n        if lookingForObject[index].centerX > ai_vison_centerX_floor and ai_vison_centerX_ceiling > lookingForObject[index].centerX:\n            drivetrain.stop()\n            wait(5, MSEC)\n            print (\"Got it Center X: \", lookingForObject[index].centerX)\n\n            print(\"centerX: \",lookingForObject[index].centerX)\n            print(\"centerY: \",lookingForObject[index].centerY)\n            print(\"Score: \",lookingForObject[index].score)\n            print(\"id: \",lookingForObject[index].id)\n            print(\"width: \",lookingForObject[index].width)\n            print(\"height: \",lookingForObject[index].height)\n            # print(\"centerX: \",objectAtIndex.centerX)\n            # print(\"centerY: \",objectAtIndex.centerY)\n            print(\"originX: \",lookingForObject[index].originX)\n            print(\"originY: \",lookingForObject[index].originY)\n            print(\"area: \",lookingForObject[index].width * lookingForObject[index].height )\n            wait(1,SECONDS)\n\n            if(ai_objects[index].id == 0):\n                gps_21.calibrate()\n                wait(50,MSEC)\n                print(\"current heading: \", gps_21.heading(), \" tunr to heading: \", gps_21.heading()+180)\n                turn_by_angle((gps_21.heading() + 180),turnVelocity)\n            break;\n\ndef vision():\n\n    # Count the objects in the snapshot\n    print(\"# of objects: \", len(ai_objects))\n\n    # If 1 or more objects are detected\n    if(len(ai_objects) > 0):\n        for index in range(0,len(ai_objects)):\n\n            #  Print the object name\n            print (\"Index: \", index)\n            print(\"Detected: \",end='')\n            if(ai_objects[index].id == 0):\n                print (\"stake\")\n                objectIndexDict[index] = \"stake\"\n            elif(ai_objects[index].id == 1):\n                print (\"Red Ring\")\n                objectIndexDict[index] = \"Red\"\n            elif(ai_objects[index].id == 2):\n                print (\"Blue Ring\")\n                objectIndexDict[index] = \"Blue\"\n\n            # Print the objective Vision AI sensor is looking for\n            print (\"objective: \", objective)\n\n            if(ai_objects[index].id == objective):\n                # This method return details of the object and where it is positioned\n                #  in reference to the center of the camera\n                turnLR = objectDetails(ai_objects[index],objective)\n                objectiveIndexAndWidthList.append({index : [ai_objects[index].width,turnLR]})\n            elif(ai_objects[index].id == objective): \n                turnLR = objectDetails(ai_objects[index],objective)\n                objectiveIndexAndWidthList.append({index : [ai_objects[index].width,turnLR]})\n            elif(ai_objects[index].id == objective):\n                turnLR = objectDetails(ai_objects[index],objective)\n                objectiveIndexAndWidthList.append({index : [ai_objects[index].width,turnLR]})       \n\n            print(\"\\n\")\n        # print(\"object Indexes: \", objectiveIndexAndWidthList[0])\n        # sequenceObjectives(objectiveIndexAndWidthList)\n        # print(\"Calling turnToObjective: \",objectiveIndexAndWidthList[0].values())\n        if len(objectiveIndexAndWidthList) > 0:\n            turnToObjective()\n        else:\n            print (\"Found \", len(ai_objects), \" objects, but no objectives in it.\\n\", ai_objects) \n    else:\n        print(\"No objects detected\")\n\nai_vison_centerX_floor = 150\nai_vison_centerX_ceiling = 170\nobjectIndexDict = {}\nobjectiveIndexAndWidthList = []\nturnVelocity = 20\nobjective = 0 # 0 - Stake , 1 - Red Ring, 2 - Blue Ring\n\nai_objects = ai_vision_2.take_snapshot(AiVision.ALL_AIOBJS)\n\nmain()\n#drivetrain.set_turn_velocity(50, PERCENT)\n#drivetrain.turn(LEFT)\n\n# drivetrain.set_turn_velocity(50,PERCENT)\n# drivetrain.turn(LEFT)\n# drivetrain.drive_for(FORWARD, 12 , INCHES)\n\n\n# vision()\nai_vision_2_objects = []\nvexcode_brain_precision = 0\nvexcode_console_precision = 0\nvexcode_controller_1_precision = 0\nai_vision_2_index = 0\nmyVariable = 0\n\n# Used to find the format string for printing numbers with the\n# desired number of decimal places\ndef print_to_console_number_format():\n        precision = 0\n        # Equivalent to setting precision to 'All Digits'\n        if vexcode_console_precision is None:\n                precision = 6\n        else:\n                precision = vexcode_console_precision\n\n#         return \"{{:.{0}f}}\".format(precision)\n# def when_started1():\n#     global myVariable, ai_vision_2_objects, vexcode_brain_precision, vexcode_console_precision, vexcode_controller_1_precision, ai_vision_2_index\n#     ai_vision_objects = ai_vision_2.take_snapshot(AiVision.ALL_AIOBJS)\n#     ai_vision_objects[0].id\n#     print(ai_vision_2_objects[0].id)\n#     print(\"# of objects:\",len(ai_vision_objects))\n#     if (len(ai_vision_objects) > 0):\n#         for index in range (0,len(ai_vision_objects)):\n#             print(ai_vision_objects)\n\n\n# # print(print_to_console_number_format().format(len(ai_vision_2_objects) if ai_vision_2_objects else 0))\n#    # ai_vision_2_index = 1 - 1\n#     #print(print_to_console_number_format().format(ai_vision_2_objects[ai_vision_2_index].width))\n\n# # create a function for handling the starting and stopping of all autonomous tasks\n# # when_started1()\n\n# Snapshot returns List of objects the camera sees on the field\n#  List is always zero indexed\nai_vision_objects = ai_vision_2.take_snapshot(AiVision.ALL_AIOBJS)\n\n# # ai_vision_objects[0].id\n# # print(ai_vision_2_objects[0].id)\n# print(\"# of objects:\",len(ai_vision_objects))\n\n\n# if (len(ai_vision_objects) > 0):\n\n\n#     for index in range (0,len(ai_vision_objects)):\n#         #print(ai_vision_objects[index].id)\n#         if(ai_vision_objects[index].id==0):\n#             print(\"stake:\")   \n#             if (ai_vision_objects[index].centerX > 150 and 170 > ai_vision_objects[index].centerX):\n#                 print(\"center\")\n#                 drivetrain.drive(FORWARD)\n#             elif (ai_vision_objects[index].centerX < 150):\n#                 print(\"left\")\n#                 drivetrain.set_turn_velocity(10, PERCENT)\n#                 drivetrain.set_drive_velocity(70, PERCENT)\n#                 intake.set_velocity(70, PERCENT)\n#                 outake.set_velocity(100, PERCENT)\n\n#                 drivetrain.turn(LEFT)\n#                 while True:\n#                     ai_vision_objects = ai_vision_2.take_snapshot(AiVision.ALL_AIOBJS)\n#                     print(\"stake:\", ai_vision_objects[index].centerX)\n#                     if (ai_vision_objects[index].centerX > 190 and 200 > ai_vision_objects[index].centerX):\n#                         #150-170(normal range)\n#                         drivetrain.stop()\n\n#                         drivetrain.drive_for(FORWARD, 50, INCHES)\n                    \n#                         break\n                        \n#                 print(ai_vision_objects[index].centerX)\n#                 ai_vision_objects = ai_vision_2.take_snapshot(AiVision.ALL_AIOBJS)\n#                 print(\"width of object is:\",ai_vision_objects[index].width)\n#                 while (ai_vision_objects[index].width> 75 and 85 > ai_vision_objects[index].width):\n#                     print (\" in the while loop, picking up object\")\n#                     drivetrain.set_turn_velocity(10, PERCENT)\n#                     drivetrain.set_drive_velocity(100, PERCENT)\n#                     intake.set_velocity(100, PERCENT)\n#                     intake.spin(FORWARD)\n#                     drivetrain.drive_for(FORWARD, 25, INCHES)\n#                     print (\"exiting while loop\")\n#                     break\n#                 print(ai_vision_objects[index].centerX) \n#             elif (ai_vision_objects[index].centerX > 170):\n#                 drivetrain.set_turn_velocity(10, PERCENT)\n#                 drivetrain.set_drive_velocity(70, PERCENT)\n#                 intake.set_velocity(100, PERCENT)\n#                 outake.set_velocity(100, PERCENT)\n\n#                 drivetrain.turn(RIGHT)\n#                     #Turn until ring is centered on vision ai sensor\n#                 while True:\n#                     ai_vision_objects = ai_vision_2.take_snapshot(AiVision.ALL_AIOBJS)\n#                     print(\"ring:\", ai_vision_objects[index].centerX)\n#                     if (ai_vision_objects[index].centerX > 200 and 210 > ai_vision_objects[index].centerX):\n#                         #150-170(normal range)\n#                         drivetrain.stop()\n#                         intake.spin(FORWARD)\n#                         outake.spin(FORWARD)\n#                         drivetrain.drive_for(FORWARD, 50, INCHES)\n                        \n#                         break\n                                \n#                     print(ai_vision_objects[index].centerX)\n#                     ai_vision_objects = ai_vision_2.take_snapshot(AiVision.ALL_AIOBJS)\n#                     print(\"width of object is:\",ai_vision_objects[index].width)\n#                         #Not running after this point\n#                         #widen gap\n#                         #or\n#                         #This while loop is used to change the distance of the robot for while loop #3     \n#                 while (ai_vision_objects[index].width> 75 and 85 > ai_vision_objects[index].width):\n#                     print (\" in the while loop, picking up object\")\n#                     drivetrain.set_turn_velocity(10, PERCENT)\n#                     drivetrain.set_drive_velocity(100, PERCENT)\n#                     intake.set_velocity(100, PERCENT)\n#                     intake.spin(FORWARD)\n#                     drivetrain.drive_for(FORWARD, 25, INCHES)\n#                     print (\"exiting while loop\")\n#                     break\n\n#         elif(ai_vision_objects[index].id==1):\n#             print(\"red ring:\")\n#             if (ai_vision_objects[index].centerX > 165 and 180 > ai_vision_objects[index].centerX):\n#                 print(\"center\")\n#                 drivetrain.set_turn_velocity(10, PERCENT)\n#                 drivetrain.set_drive_velocity(70, PERCENT)\n#                 intake.set_velocity(70, PERCENT)\n#                 outake.set_velocity(100, PERCENT)\n\n#                 intake.spin(FORWARD)\n#                 outake.spin(FORWARD)\n#                 drivetrain.drive_for(FORWARD, 50, INCHES)\n#                 intake.stop()\n#                 outake.stop()\n#                 break\n                \n#             elif (ai_vision_objects[index].centerX < 150):\n#                 print(\"left\")\n#                 drivetrain.set_turn_velocity(10, PERCENT)\n#                 drivetrain.set_drive_velocity(70, PERCENT)\n#                 intake.set_velocity(70, PERCENT)\n#                 outake.set_velocity(100, PERCENT)\n\n#                 drivetrain.turn(LEFT)\n#                 while True:\n#                     ai_vision_objects = ai_vision_2.take_snapshot(AiVision.ALL_AIOBJS)\n#                     print(\"ring:\", ai_vision_objects[index].centerX)\n#                     if (ai_vision_objects[index].centerX > 190 and 200 > ai_vision_objects[index].centerX):\n#                         #150-170(normal range)\n#                         drivetrain.stop()\n#                         intake.spin(FORWARD)\n#                         outake.spin(FORWARD)\n#                         drivetrain.drive_for(FORWARD, 50, INCHES)\n#                         intake.stop()\n#                         outake.stop()\n#                         break\n                        \n#                 print(ai_vision_objects[index].centerX)\n#                 ai_vision_objects = ai_vision_2.take_snapshot(AiVision.ALL_AIOBJS)\n#                 print(\"width of object is:\",ai_vision_objects[index].width)\n#                 while (ai_vision_objects[index].width> 75 and 85 > ai_vision_objects[index].width):\n#                     print (\" in the while loop, picking up object\")\n#                     drivetrain.set_turn_velocity(10, PERCENT)\n#                     drivetrain.set_drive_velocity(100, PERCENT)\n#                     intake.set_velocity(100, PERCENT)\n#                     intake.spin(FORWARD)\n#                     drivetrain.drive_for(FORWARD, 25, INCHES)\n#                     print (\"exiting while loop\")\n#                     break\n#             #Right Red Ring\n#             elif (ai_vision_objects[index].centerX > 170):\n#                 print(\"right\")\n#                 drivetrain.set_turn_velocity(10, PERCENT)\n#                 drivetrain.set_drive_velocity(70, PERCENT)\n#                 intake.set_velocity(70, PERCENT)\n#                 outake.set_velocity(100, PERCENT)\n\n#                 drivetrain.turn(RIGHT)\n#                 #Turn until ring is centered on vision ai sensor\n#                 while True:\n#                     ai_vision_objects = ai_vision_2.take_snapshot(AiVision.ALL_AIOBJS)\n#                     print(\"ring:\", ai_vision_objects[index].centerX)\n#                     if (ai_vision_objects[index].centerX > 190 and 200 > ai_vision_objects[index].centerX):\n#                         #150-170(normal range)\n#                         drivetrain.stop()\n#                         intake.spin(FORWARD)\n#                         outake.spin(FORWARD)\n#                         drivetrain.drive_for(FORWARD, 50, INCHES)\n#                         intake.stop()\n#                         outake.stop()\n#                         break\n                        \n#                 print(ai_vision_objects[index].centerX)\n#                 ai_vision_objects = ai_vision_2.take_snapshot(AiVision.ALL_AIOBJS)\n#                 print(\"width of object is:\",ai_vision_objects[index].width)\n#                 #Not running after this point\n#                 #widen gap\n#                 #or\n#                 #This while loop is used to change the distance of the robot for while loop #3     \n#                 while (ai_vision_objects[index].width> 75 and 85 > ai_vision_objects[index].width):\n#                     print (\" in the while loop, picking up object\")\n#                     drivetrain.set_turn_velocity(10, PERCENT)\n#                     drivetrain.set_drive_velocity(100, PERCENT)\n#                     intake.set_velocity(100, PERCENT)\n#                     intake.spin(FORWARD)\n#                     drivetrain.drive_for(FORWARD, 25, INCHES)\n#                     print (\"exiting while loop\")\n#                     break\n#         #Blue ring code:\n#         elif(ai_vision_objects[index].id==2):\n#             print(\"blue ring:\")\n#         #If the blue ring is in between the values of 150 and 170 then \n#             if (ai_vision_objects[index].centerX > 165 and 180 > ai_vision_objects[index].centerX):\n#                 print(\"center\")\n#                 drivetrain.set_turn_velocity(10, PERCENT)\n#                 drivetrain.set_drive_velocity(70, PERCENT)\n#                 intake.set_velocity(70, PERCENT)\n#                 outake.set_velocity(100, PERCENT)\n\n#                 intake.spin(FORWARD)\n#                 outake.spin(FORWARD)\n#                 drivetrain.drive_for(FORWARD, 50, INCHES)\n#                 break\n\n#             elif (ai_vision_objects[index].centerX < 150):\n#                 print(\"left\")\n#                 drivetrain.set_turn_velocity(10, PERCENT)\n#                 drivetrain.set_drive_velocity(70, PERCENT)\n#                 intake.set_velocity(70, PERCENT)\n#                 outake.set_velocity(100, PERCENT)\n\n#                 drivetrain.turn(LEFT)\n#                 while True:\n#                     ai_vision_objects = ai_vision_2.take_snapshot(AiVision.ALL_AIOBJS)\n#                     print(\"ring:\", ai_vision_objects[index].centerX)\n#                     if (ai_vision_objects[index].centerX > 190 and 200 > ai_vision_objects[index].centerX):\n#                         #150-170(normal range)\n#                         drivetrain.stop()\n#                         intake.spin(FORWARD)\n#                         outake.spin(FORWARD)\n#                         drivetrain.drive_for(FORWARD, 50, INCHES)\n#                         break\n                        \n#                 print(ai_vision_objects[index].centerX)\n#                 ai_vision_objects = ai_vision_2.take_snapshot(AiVision.ALL_AIOBJS)\n#                 print(\"width of object is:\",ai_vision_objects[index].width)\n#                 while (ai_vision_objects[index].width> 75 and 85 > ai_vision_objects[index].width):\n#                     print (\" in the while loop, picking up object\")\n#                     drivetrain.set_turn_velocity(10, PERCENT)\n#                     drivetrain.set_drive_velocity(100, PERCENT)\n#                     intake.set_velocity(100, PERCENT)\n#                     intake.spin(FORWARD)\n#                     drivetrain.drive_for(FORWARD, 25, INCHES)\n#                     print (\"exiting while loop\")\n#                     break\n                \n#             elif (ai_vision_objects[index].centerX > 170):\n#                 print(\"right\")\n#                 drivetrain.set_turn_velocity(10, PERCENT)\n#                 drivetrain.set_drive_velocity(70, PERCENT)\n#                 intake.set_velocity(100, PERCENT)\n#                 outake.set_velocity(100, PERCENT)\n\n#                 drivetrain.turn(RIGHT)\n#                     #Turn until ring is centered on vision ai sensor\n#                 while True:\n#                     ai_vision_objects = ai_vision_2.take_snapshot(AiVision.ALL_AIOBJS)\n#                     print(\"ring:\", ai_vision_objects[index].centerX)\n#                     if (ai_vision_objects[index].centerX > 200 and 210 > ai_vision_objects[index].centerX):\n#                         #150-170(normal range)\n#                         drivetrain.stop()\n#                         intake.spin(FORWARD)\n#                         outake.spin(FORWARD)\n#                         drivetrain.drive_for(FORWARD, 50, INCHES)\n                        \n#                         break\n                                \n#                     print(ai_vision_objects[index].centerX)\n#                     ai_vision_objects = ai_vision_2.take_snapshot(AiVision.ALL_AIOBJS)\n#                     print(\"width of object is:\",ai_vision_objects[index].width)\n#                         #Not running after this point\n#                         #widen gap\n#                         #or\n#                         #This while loop is used to change the distance of the robot for while loop #3     \n#                 while (ai_vision_objects[index].width> 75 and 85 > ai_vision_objects[index].width):\n#                     print (\" in the while loop, picking up object\")\n#                     drivetrain.set_turn_velocity(10, PERCENT)\n#                     drivetrain.set_drive_velocity(100, PERCENT)\n#                     intake.set_velocity(100, PERCENT)\n#                     intake.spin(FORWARD)\n#                     drivetrain.drive_for(FORWARD, 25, INCHES)\n#                     print (\"exiting while loop\")\n#                     break\n# drivetrain.set_drive_velocity(100, PERCENT)\n# drivetrain.set_turn_velocity(100, PERCENT)\n# drivetrain.drive_for(FORWARD, 30, INCHES)\n# print(\"turning 270 clockwise\")\n# print(\"heading is:\",gps_21.heading())\n# gpsHeading = gps_21.heading()\n# turn_by_angle(0,turnSpeed) \n# print(gps_21.heading())\n\nleftPuem.set(True)\nrightPUEM.set(True)\ndrivetrain.set_drive_velocity(100, PERCENT)\ndrivetrain.set_turn_velocity(100, PERCENT)\ndrivetrain.drive_for(FORWARD, -93, INCHES)\ndrivetrain.turn_for(LEFT, 45, DEGREES)\nprint(gps_21.heading())\ngpsHeading = gps_21.heading()\nturn_by_angle(94,turnSpeed) \ndrivetrain.drive_for(FORWARD, -20, INCHES)\nwait(3, SECONDS)\nleftPuem.set(False)\nrightPUEM.set(False)\nwait(3, SECONDS)\ndrivetrain.drive_for(FORWARD, 20, INCHES)\nleftPuem.set(True)\nrightPUEM.set(True)\nwait(3, SECONDS)\ndrivetrain.drive_for(FORWARD, 5, INCHES)\nwait(3, SECONDS)\ndrivetrain.drive_for(FORWARD, -6, INCHES)\nleftPuem.set(False)\nrightPUEM.set(False)\nprint(\"complete drive\")\n#(ai_vision_objects[index].id==0)\n# while True:\n#     ai_vision_objects = ai_vision_2.take_snapshot(AiVision.ALL_AIOBJS)\n#     print(\"stake:\", ai_vision_objects[index].centerX)\n# intake.spin(FORWARD)\n    # if (ai_vision_objects[index].centerX > 190 and 200 > ai_vision_objects[index].centerX):\n#         #150-170(normal range)\n#         drivetrain.stop()\n#         drivetrain.drive_for(FORWARD, 50, INCHES)\n#         break\n\n","textLanguage":"python","robotConfig":[{"port":[20,11,12,16,0],"name":"drivetrain","customName":false,"deviceType":"Drivetrain","deviceClass":"smartdrive","setting":{"type":"4-motor","wheelSize":"wheel275in","gear":"ratio18_1","gearRatio":"1:1","direction":"rev","gyroType":"none","width":"295","unit":"mm","wheelbase":"40","wheelbaseUnit":"mm","xOffset":"0","xOffsetUnit":"mm","yOffset":"0","yOffsetUnit":"mm","thetaOffset":"180"},"triportSourcePort":null},{"port":[1],"name":"leftPuem","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{},"triportSourcePort":22},{"port":[2],"name":"rightPUEM","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{},"triportSourcePort":22},{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"arcader","id":"primary"},"triportSourcePort":22},{"port":[1],"name":"intake","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[8],"name":"outake","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[21],"name":"gps_21","customName":false,"deviceType":"GPS","deviceClass":"gps","setting":{"xOffset":"132.08","xOffsetUnit":"mm","yOffset":"-88.9","yOffsetUnit":"mm","thetaOffset":"0"},"triportSourcePort":22},{"port":[2],"name":"ai_vision_2","customName":false,"deviceType":"AIVision","deviceClass":"aivision","setting":{"config":"{\"colors\":[],\"codes\":[],\"tags\":false,\"AIObjects\":true,\"AIObjectModel\":[\"Ball(Blue)\",\"Ball(Green)\",\"Ball(Red)\",\"Ring(Blue)\",\"Ring(Green)\",\"Ring(Red)\",\"Cube(Blue)\",\"Cube(Green)\",\"Cube(Red)\"],\"AIModelMetadata\":{\"id\":0,\"version\":1,\"name\":\"Classroom Objects\"},\"aiModelDropDownValue\":\"2024-2025 High Stakes\"}","isConfigured":"false"},"triportSourcePort":22},{"port":[3],"name":"right_rotation","customName":true,"deviceType":"Rotation","deviceClass":"rotation","setting":{"reversed":"false","id":"partner"},"triportSourcePort":22},{"port":[14],"name":"left_rotation","customName":true,"deviceType":"Rotation","deviceClass":"rotation","setting":{"reversed":"false","id":"partner"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.7","minVersion":"3.1.0","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}